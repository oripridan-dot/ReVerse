# -*- coding: utf-8 -*-
"""tests/test_process_job.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F8fpn0hRchGBjRiTOe95HIauMfAuxVlF
"""

import asyncio
from typing import Callable, Tuple, Any

import pytest
from sqlalchemy import select, create_engine
from sqlalchemy.engine import Engine
from sqlalchemy.orm import Session, sessionmaker
from sqlalchemy.pool import StaticPool
from tenacity import RetryError

from src.reverse import main_enterprise


class FakeAsyncSession:
    """Minimal async wrapper around a synchronous SQLAlchemy session."""

    def __init__(self, sync_session: Session):
        self._sync_session = sync_session

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc, tb):
        try:
            if exc_type is not None:
                self._sync_session.rollback()
        finally:
            self._sync_session.close()

    def add(self, instance: Any):
        self._sync_session.add(instance)

    async def execute(self, statement: Any):
        return self._sync_session.execute(statement)

    async def commit(self):
        self._sync_session.commit()

    async def rollback(self):
        self._sync_session.rollback()


def _setup_in_memory_db() -> Tuple[Engine, Callable[[], FakeAsyncSession]]:
    """Create an in-memory SQLite database for job processing tests."""
    engine = create_engine(
        "sqlite://",
        connect_args={"check_same_thread": False},
        poolclass=StaticPool,
        future=True,
    )
    main_enterprise.Base.metadata.create_all(engine)

    sync_session_factory = sessionmaker(bind=engine, expire_on_commit=False)

    def factory() -> FakeAsyncSession:
        return FakeAsyncSession(sync_session_factory())

    return engine, factory


def _prepare_app_state(
    session_factory: Callable[[], FakeAsyncSession], engine: Engine
) -> Tuple:
    """Swap in the temporary session factory for the app state."""
    original_factory = main_enterprise.app_state.db_session_factory
    original_engine = main_enterprise.app_state.db_engine

    main_enterprise.app_state.db_session_factory = session_factory
    main_enterprise.app_state.db_engine = engine

    return original_factory, original_engine


def _cleanup_app_state(engine: Engine, original_factory: Any, original_engine: Any) -> None:
    """Restore the app state after a test run."""
    main_enterprise.app_state.db_session_factory = original_factory
    main_enterprise.app_state.db_engine = original_engine
    engine.dispose()


def test_process_job_updates_json_with_apostrophes(monkeypatch):
    asyncio.run(_test_process_job_updates_json_with_apostrophes(monkeypatch))


async def _test_process_job_updates_json_with_apostrophes(monkeypatch):
    engine, session_factory = _setup_in_memory_db()
    original_factory, original_engine = _prepare_app_state(session_factory, engine)

    job_id = "job-apostrophes-success"
    prompt = "Explain why it's important to protect users' data."
    job_payload = {
        "id": job_id,
        "user_id": "user-123",
        "prompt": prompt,
        "agents": ["Analyst"],
    }

    agent_result = {
        "analysis": "It's critical to respect users' privacy so their trust isn't broken.",
        "echo": "Original prompt was: " + prompt,
    }

    async def fake_execute_agent(job: Any):
        assert job["prompt"] == prompt
        return agent_result

    monkeypatch.setattr(main_enterprise, "execute_agent_pipeline", fake_execute_agent)

    try:
        async with session_factory() as session:
            session.add(
                main_enterprise.Job(
                    id=job_id,
                    user_id="user-123",
                    status="pending",
                    payload=job_payload,
                )
            )
            await session.commit()

        await main_enterprise.process_job(job_payload)

        async with session_factory() as session:
            stored_job = (
                await session.execute(
                    select(main_enterprise.Job).where(main_enterprise.Job.id == job_id)
                )
            ).scalar_one()

            assert stored_job.status == "completed"
            assert stored_job.completed_at is not None
            assert stored_job.error is None
            assert stored_job.result == agent_result
    finally:
        _cleanup_app_state(engine, original_factory, original_engine)


def test_process_job_records_error_with_apostrophes(monkeypatch):
    asyncio.run(_test_process_job_records_error_with_apostrophes(monkeypatch))


async def _test_process_job_records_error_with_apostrophes(monkeypatch):
    engine, session_factory = _setup_in_memory_db()
    original_factory, original_engine = _prepare_app_state(session_factory, engine)

    job_id = "job-apostrophes-failure"
    prompt = "Show how the agent's failure is handled."
    job_payload = {
        "id": job_id,
        "user_id": "user-456",
        "prompt": prompt,
        "agents": ["Critic"],
    }

    async def failing_execute_agent(job: Any):
        raise RuntimeError("Agent couldn't parse the user's prompt.")

    monkeypatch.setattr(main_enterprise, "execute_agent_pipeline", failing_execute_agent)

    try:
        async with session_factory() as session:
            session.add(
                main_enterprise.Job(
                    id=job_id,
                    user_id="user-456",
                    status="pending",
                    payload=job_payload,
                )
            )
            await session.commit()

        with pytest.raises(RetryError) as exc_info:
            await main_enterprise.process_job(job_payload)

        assert isinstance(exc_info.value.last_attempt.exception, RuntimeError)

        async with session_factory() as session:
            stored_job = (
                await session.execute(
                    select(main_enterprise.Job).where(main_enterprise.Job.id == job_id)
                )
            ).scalar_one()

            assert stored_job.status == "failed"
            assert stored_job.result is None
            assert (
                stored_job.error
                == "Agent couldn't parse the user's prompt."
            )
    finally:
        _cleanup_app_state(engine, original_factory, original_engine)