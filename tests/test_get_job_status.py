# -*- coding: utf-8 -*-
"""tests/test_get_job_status.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T_2C1Qo3-nbHfBBz1kefv60-G4r0Pzgm
"""

import asyncio
from datetime import datetime, timedelta, timezone

import pytest

pytest.importorskip("aiosqlite", reason="aiosqlite is required for async SQLite tests")
from fastapi import HTTPException
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from src.reverse.main_enterprise import Base, Job, TokenData, app_state, get_job_status


async def initialize_test_database():
    """Create an isolated in-memory database for each test."""
    engine = create_async_engine("sqlite+aiosqlite:///:memory:")
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    session_factory = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

    original_factory = app_state.db_session_factory
    original_engine = app_state.db_engine

    app_state.db_engine = engine
    app_state.db_session_factory = session_factory

    return engine, session_factory, original_factory, original_engine


async def finalize_test_database(engine, original_factory, original_engine):
    """Dispose of the test database and restore application state."""
    app_state.db_session_factory = original_factory
    app_state.db_engine = original_engine
    await engine.dispose()


def create_token(user_id: str) -> TokenData:
    return TokenData(
        user_id=user_id,
        exp=datetime.now(timezone.utc) + timedelta(hours=1),
        scopes=[]
    )


def test_get_job_status_returns_matching_job():
    asyncio.run(_test_get_job_status_returns_matching_job())


async def _test_get_job_status_returns_matching_job():
    engine, session_factory, original_factory, original_engine = await initialize_test_database()
    try:
        token = create_token("user-123")
        job_id = "job-1"

        async with session_factory() as session:
            session.add(
                Job(
                    id=job_id,
                    user_id=token.user_id,
                    status="completed",
                    payload={"prompt": "example"},
                    result={"message": "done"}
                )
            )
            await session.commit()

        response = await get_job_status(job_id, token=token)

        assert response.job_id == job_id
        assert response.status == "completed"
        assert response.result == {"message": "done"}
    finally:
        await finalize_test_database(engine, original_factory, original_engine)


def test_get_job_status_rejects_sql_injection_attempt():
    asyncio.run(_test_get_job_status_rejects_sql_injection_attempt())


async def _test_get_job_status_rejects_sql_injection_attempt():
    engine, session_factory, original_factory, original_engine = await initialize_test_database()
    try:
        token = create_token("user-123")
        job_id = "job-2"

        async with session_factory() as session:
            session.add(
                Job(
                    id=job_id,
                    user_id=token.user_id,
                    status="processing",
                    payload={"prompt": "another"}
                )
            )
            await session.commit()

        malicious_job_id = f"{job_id}' OR '1'='1"

        with pytest.raises(HTTPException) as exc_info:
            await get_job_status(malicious_job_id, token=token)

        assert exc_info.value.status_code == 404
    finally:
        await finalize_test_database(engine, original_factory, original_engine)