# -*- coding: utf-8 -*-
"""src/reverse/enterprise_support_files.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A_zFCfJCtyZOF9rt2aMxLyiqiv8ti8on
"""

# requirements.txt
# Core
fastapi==0.104.1
uvicorn[standard]==0.24.0
python-socketio==5.10.0
python-multipart==0.0.6

# Database
sqlalchemy==2.0.23
asyncpg==0.29.0
alembic==1.12.1

# Redis
redis==5.0.1
hiredis==2.2.3

# Security
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
cryptography==41.0.7

# Validation
pydantic==2.5.0
pydantic-settings==2.1.0
email-validator==2.1.0

# Monitoring
prometheus-client==0.19.0
sentry-sdk==1.38.0
python-json-logger==2.0.7

# Utilities
python-dotenv==1.0.0
tenacity==8.2.3
py-circuit-breaker==0.1.4
httpx==0.25.2
aiofiles==23.2.1

# Testing
pytest==7.4.3
pytest-asyncio==0.21.1
pytest-cov==4.1.0
pytest-mock==3.12.0
pytest-benchmark==4.0.0
factory-boy==3.3.0
faker==20.1.0
httpx==0.25.2

# Development
black==23.11.0
ruff==0.1.6
mypy==1.7.1
pre-commit==3.5.0
ipython==8.17.2

---
# .env.example
# Application
APP_NAME="ReVerse Enterprise"
APP_VERSION="4.0.0"
DEBUG=false
ENVIRONMENT=production
LOG_LEVEL=INFO

# Security
SECRET_KEY=your-secret-key-minimum-32-characters-long-generate-with-secrets
JWT_ALGORITHM=HS256
JWT_EXPIRATION_HOURS=24
API_KEY_HEADER=X-API-Key
ALLOWED_HOSTS=["*"]
CORS_ORIGINS=["https://yourdomain.com"]

# Database
DATABASE_URL=postgresql://user:password@localhost:5432/reverse
DATABASE_POOL_SIZE=20
DATABASE_MAX_OVERFLOW=40

# Redis
REDIS_URL=redis://localhost:6379
REDIS_POOL_SIZE=10
REDIS_DECODE_RESPONSES=true

# Rate Limiting
RATE_LIMIT_PER_MINUTE=60
RATE_LIMIT_BURST=10

# Monitoring
SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id
METRICS_ENABLED=true

# AI Configuration
OPENAI_API_KEY=your-openai-api-key
OLLAMA_HOST=http://localhost:11434
DEFAULT_MODEL=phi3:mini
MAX_AGENTS=10
AGENT_TIMEOUT=30
AGENT_RETRY_ATTEMPTS=3

---
# test_main.py
"""
Comprehensive test suite for ReVerse Enterprise
"""

import pytest
import asyncio
import json
from datetime import datetime, timedelta, timezone
from typing import AsyncGenerator
from unittest.mock import Mock, patch, AsyncMock

import httpx
from fastapi import status
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from src.reverse.main_enterprise import app, get_settings, create_access_token, Job, ApplicationState


# Fixtures
@pytest.fixture
def settings():
    """Override settings for testing"""
    with patch('src.reverse.main_enterprise.get_settings') as mock_settings:
        mock_settings.return_value = Mock(
            secret_key=Mock(get_secret_value=lambda: "test-secret-key-32-characters-long"),
            jwt_algorithm="HS256",
            jwt_expiration_hours=24,
            database_url="sqlite+aiosqlite:///:memory:",
            redis_url="redis://localhost:6379",
            environment="testing",
            debug=True
        )
        yield mock_settings.return_value


@pytest.fixture
async def test_db():
    """Create test database"""
    engine = create_async_engine("sqlite+aiosqlite:///:memory:")
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

    async with async_session() as session:
        yield session

    await engine.dispose()


@pytest.fixture
async def client() -> AsyncGenerator:
    """Create test client"""
    async with httpx.AsyncClient(app=app, base_url="http://test") as ac:
        yield ac


@pytest.fixture
def auth_token():
    """Generate test authentication token"""
    return create_access_token("test-user-123", ["read", "write"])


@pytest.fixture
def auth_headers(auth_token):
    """Generate auth headers"""
    return {"Authorization": f"Bearer {auth_token}"}


# Unit Tests
class TestSecurity:
    """Test security functions"""

    def test_create_access_token(self, settings):
        """Test JWT token creation"""
        token = create_access_token("user123", ["read"])
        assert token is not None
        assert isinstance(token, str)
        assert len(token) > 0

    def test_token_expiration(self, settings):
        """Test token expiration"""
        token = create_access_token("user123", ["read"])
        # Decode and verify expiration
        import jose
        payload = jose.jwt.decode(
            token,
            settings.secret_key.get_secret_value(),
            algorithms=[settings.jwt_algorithm]
        )
        exp = datetime.fromtimestamp(payload['exp'], tz=timezone.utc)
        assert exp > datetime.now(timezone.utc)
        assert exp < datetime.now(timezone.utc) + timedelta(hours=25)


class TestModels:
    """Test database models"""

    @pytest.mark.asyncio
    async def test_job_creation(self, test_db):
        """Test job model creation"""
        job = Job(
            id="test-job-123",
            user_id="user-123",
            status="pending",
            payload={"test": "data"}
        )
        test_db.add(job)
        await test_db.commit()

        result = await test_db.get(Job, "test-job-123")
        assert result is not None
        assert result.user_id == "user-123"
        assert result.status == "pending"


# Integration Tests
class TestAPI:
    """Test API endpoints"""

    @pytest.mark.asyncio
    async def test_health_check(self, client):
        """Test health endpoint"""
        response = await client.get("/health")
        assert response.status_code == 200
        data = response.json()
        assert data["status"] in ["healthy", "degraded"]
        assert "version" in data
        assert "timestamp" in data

    @pytest.mark.asyncio
    async def test_create_job_unauthorized(self, client):
        """Test job creation without auth"""
        response = await client.post(
            "/api/v1/jobs",
            json={"idea": "Test idea", "agents": ["Critic"]}
        )
        assert response.status_code == status.HTTP_403_FORBIDDEN

    @pytest.mark.asyncio
    async def test_create_job_authorized(self, client, auth_headers):
        """Test job creation with auth"""
        with patch('src.reverse.main_enterprise.app_state.redis_client') as mock_redis:
            mock_redis.rpush = AsyncMock(return_value=True)

            response = await client.post(
                "/api/v1/jobs",
                headers=auth_headers,
                json={
                    "idea": "Test idea for analysis",
                    "agents": ["Critic", "Coder"],
                    "priority": "normal"
                }
            )

            assert response.status_code == status.HTTP_201_CREATED
            data = response.json()
            assert "job_id" in data
            assert data["status"] == "pending"

    @pytest.mark.asyncio
    async def test_get_job_status(self, client, auth_headers, test_db):
        """Test retrieving job status"""
        # Create a test job
        job = Job(
            id="test-job-456",
            user_id="test-user-123",
            status="completed",
            result={"test": "result"}
        )
        test_db.add(job)
        await test_db.commit()

        response = await client.get(
            "/api/v1/jobs/test-job-456",
            headers=auth_headers
        )

        assert response.status_code == 200
        data = response.json()
        assert data["job_id"] == "test-job-456"
        assert data["status"] == "completed"

    @pytest.mark.asyncio
    async def test_invalid_job_request(self, client, auth_headers):
        """Test validation for invalid job requests"""
        response = await client.post(
            "/api/v1/jobs",
            headers=auth_headers,
            json={
                "idea": "",  # Empty idea should fail
                "agents": ["InvalidAgent"],  # Invalid agent
                "priority": "super-urgent"  # Invalid priority
            }
        )

        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY


# WebSocket Tests
class TestWebSocket:
    """Test WebSocket functionality"""

    @pytest.mark.asyncio
    async def test_websocket_connection(self):
        """Test WebSocket connection"""
        import socketio

        sio = socketio.AsyncClient()

        connected = False

        @sio.event
        async def connect():
            nonlocal connected
            connected = True

        await sio.connect('http://localhost:8000')
        await asyncio.sleep(0.5)

        assert connected
        await sio.disconnect()


# Performance Tests
class TestPerformance:
    """Test performance characteristics"""

    @pytest.mark.benchmark(group="api")
    def test_token_generation_performance(self, benchmark, settings):
        """Benchmark token generation"""
        result = benchmark(create_access_token, "user123", ["read", "write"])
        assert result is not None

    @pytest.mark.asyncio
    @pytest.mark.benchmark(group="database")
    async def test_database_query_performance(self, benchmark, test_db):
        """Benchmark database queries"""
        async def query():
            return await test_db.execute("SELECT 1")

        await benchmark(query)


# Load Tests
class TestLoad:
    """Load testing"""

    @pytest.mark.asyncio
    async def test_concurrent_requests(self, client, auth_headers):
        """Test handling concurrent requests"""
        async def make_request():
            return await client.get("/health")

        tasks = [make_request() for _ in range(100)]
        responses = await asyncio.gather(*tasks)

        success_count = sum(1 for r in responses if r.status_code == 200)
        assert success_count == 100


# Run tests
if __name__ == "__main__":
    pytest.main([__file__, "-v", "--cov=src/reverse/main_enterprise", "--cov-report=term-missing"])